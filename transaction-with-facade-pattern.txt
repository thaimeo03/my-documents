Vai tr√≤ c·ªßa @Version trong Hibernate/JPA r·∫•t ƒë·∫∑c bi·ªát v√¨ n√≥ ho·∫°t ƒë·ªông ho√†n to√†n t·ª± ƒë·ªông. B·∫°n kh√¥ng c·∫ßn ph·∫£i vi·∫øt code ƒë·ªÉ so s√°nh version hay b·∫Øt exception m·ªôt c√°ch th·ªß c√¥ng trong Business Logic n·∫øu b·∫°n mu·ªën h√†nh vi m·∫∑c ƒë·ªãnh l√† "fail and rollback".

D∆∞·ªõi ƒë√¢y l√† c∆° ch·∫ø chi ti·∫øt:

1. C∆° ch·∫ø truy v·∫•n t·ª± ƒë·ªông (SQL)
Khi b·∫°n l∆∞u m·ªôt th·ª±c th·ªÉ c√≥ @Version, Hibernate s·∫Ω kh√¥ng ch·∫°y l·ªánh UPDATE th√¥ng th∆∞·ªùng. Thay v√†o ƒë√≥, n√≥ s·∫Ω ƒë√≠nh k√®m th√™m ƒëi·ªÅu ki·ªán version v√†o c√¢u l·ªánh SQL:

L√∫c ƒë·ªçc d·ªØ li·ªáu: SELECT id, stock, version FROM products WHERE id = 1 (Gi·∫£ s·ª≠ l·∫•y ƒë∆∞·ª£c stock = 10, version = 5).
L√∫c l∆∞u d·ªØ li·ªáu (save): Hibernate s·∫Ω sinh ra c√¢u l·ªánh:
sql
UPDATE products 
SET stock = 9, version = 6 -- T·ª± tƒÉng version l√™n 1
WHERE id = 1 AND version = 5; -- Ch·ªâ update n·∫øu version v·∫´n l√† 5
2. Check version nh∆∞ th·∫ø n√†o?
Hibernate s·∫Ω ki·ªÉm tra s·ªë l∆∞·ª£ng d√≤ng b·ªã t√°c ƒë·ªông (row count) c·ªßa c√¢u l·ªánh UPDATE tr√™n:

N·∫øu row count = 1: Th√†nh c√¥ng.
N·∫øu row count = 0: Nghƒ©a l√† c√≥ ai ƒë√≥ ƒë√£ update d√≤ng n√†y tr∆∞·ªõc b·∫°n (l√†m version trong DB tƒÉng l√™n 6 ch·∫≥ng h·∫°n), n√™n ƒëi·ªÅu ki·ªán WHERE version = 5 kh√¥ng c√≤n kh·ªõp. Hibernate s·∫Ω hi·ªÉu ngay l√† ƒë√£ c√≥ xung ƒë·ªôt (Optimistic Lock).

PESSIMISTIC_READ allows us to obtain a shared lock and prevent the data from being updated or deleted.
PESSIMISTIC_WRITE allows us to obtain an exclusive lock and prevent the data from being read, updated or deleted.
PESSIMISTIC_FORCE_INCREMENT works like PESSIMISTIC_WRITE, and it additionally increments a version attribute of a versioned entity.

1Ô∏è‚É£ Facade Service l√† g√¨? (hi·ªÉu ƒë√∫ng b·∫£n ch·∫•t)

Facade Service l√† l·ªõp ƒëi·ªÅu ph·ªëi (orchestrator):

KH√îNG ch·ª©a logic DB n·∫∑ng

KH√îNG x·ª≠ l√Ω transaction chi ti·∫øt

Ch·ªâ:

validate

g·ªçi nhi·ªÅu service con

ƒëi·ªÅu ph·ªëi flow nghi·ªáp v·ª•

üëâ Transaction th·∫≠t s·ª± n·∫±m ·ªü service con, kh√¥ng n·∫±m ·ªü facade.

2Ô∏è‚É£ Khi n√†o n√™n d√πng Facade Service?

D√πng khi:

1 use-case g·ªçi nhi·ªÅu service

C√≥ nhi·ªÅu b∆∞·ªõc nghi·ªáp v·ª•

Mu·ªën:

tr√°nh self-invocation

ki·ªÉm so√°t transaction r√µ r√†ng

d·ªÖ rollback theo t·ª´ng b∆∞·ªõc

üí° R·∫•t ph·ªï bi·∫øn trong:

Import / Batch

Workflow nhi·ªÅu b∆∞·ªõc

Banking / Payment / Order

3Ô∏è‚É£ C·∫•u tr√∫c chu·∫©n (th·ª±c t·∫ø ƒëi l√†m)
Controller
   |
   v
Facade Service  (NO @Transactional)
   |
   +--> Tx Service A (@Transactional)
   |
   +--> Tx Service B (@Transactional)

4Ô∏è‚É£ V√≠ d·ª• c·ª• th·ªÉ (chu·∫©n production)
4.1 Controller
@RestController
@RequestMapping("/orders")
public class OrderController {

    private final OrderFacade orderFacade;

    public OrderController(OrderFacade orderFacade) {
        this.orderFacade = orderFacade;
    }

    @PostMapping
    public void createOrder() {
        orderFacade.createOrder();
    }
}

4.2 Facade Service (KH√îNG transaction)
@Service
public class OrderFacade {

    private final OrderTxService orderTxService;
    private final InventoryTxService inventoryTxService;

    public OrderFacade(
        OrderTxService orderTxService,
        InventoryTxService inventoryTxService
    ) {
        this.orderTxService = orderTxService;
        this.inventoryTxService = inventoryTxService;
    }

    public void createOrder() {
        // orchestration only
        orderTxService.createOrder();
        inventoryTxService.reserveStock();
    }
}


‚úî Kh√¥ng @Transactional
‚úî Ch·ªâ ƒëi·ªÅu ph·ªëi
‚úî Kh√¥ng DB logic

4.3 Transactional Services
@Service
public class OrderTxService {

    @Transactional
    public void createOrder() {
        // insert order
    }
}

@Service
public class InventoryTxService {

    @Transactional
    public void reserveStock() {
        // update stock
    }
}


‚úî Transaction ƒë∆∞·ª£c m·ªü ƒë√∫ng ch·ªó
‚úî Kh√¥ng self-invocation
‚úî D·ªÖ test
